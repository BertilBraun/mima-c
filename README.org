#+TITLE: Readme

* Sprache:
1. Arithmetic Expressions
   #+begin_example
   (1 + 2 - 2 / 3 * -5 % 10)
   #+end_example
2. Variables (Assignment)
   #+begin_example
   int a = 5;
   #+end_example
   We differentiate between:
   - Global
   - Local
   Variables
   /Note:/
      Assignment returns the assigned value to allow for:
      #+begin_example
      a = b = 5;
      #+end_example
3. Scope
   - *local* scope:
     #+begin_example
     {
     int a = 1;
     int b = 1;
             {
                 int b = 5;
                 a + b;
             }
     }
     #+end_example
   - *global* scope

4. Function declaration
   If we do a single pass compiler we need forward delaration
   ?How will this work for the compiler?
5. Functiondefinition
   void a(int b, int c) { BODY }
6. Functioncalls
   a(b, c)

* Grammar
#+begin_src
expr         -> varassign
;; this is ok to do recursively because it is right associative
varassign    -> [IDENTIFIER, EQUALS] varassign | add
add          -> (factor [PLUS, MINUS])* factor
factor       -> (mod [MULTIPLY, DIVIDE])* mod
mod          -> (unary [MODULO])* unary
unary        -> MINUS value | value
value        -> INTLITERAL | LPAREN expr RPAREN | functioncall | IDENTIFIER
functioncall -> IDENTIFIER LPAREN functionargs RPAREN
#+end_src

#+begin_src
funcdecl  -> IDENTIFIER IDENTIFIER LPAREN functionparam RPAREN [;, block]
#+end_src

#+begin_src block
block     -> LBRACE (statement)* RBRACE
#+end_src

#+begin_src
statement    -> [vardecl, varassign, expr] ;
vardecl      -> IDENTIFIER IDENTIFIER (= expr)? (, IDENTIFIER (= expr)?)*
varassign    -> IDENTIFIER = expr
#+end_src

#+begin_src
program -> ([statement, funcdecl, block])*
#+end_src


* Modules:
** Preprozessor
- Comments
- (Macros)
** Lexer
- Generates Tokens
Difficulty?:
- Handles strings
** Parser
Generates AST to be used by compiler / interpreter
What type of parser?
- Recursive descent?
- Parser combinators?

** Interpreter
** Compiler (future)
- Single file (at least no linker)
- (type system)
*** Address Space:
- Code
- Data
- Registers (pseudo)
- Stack
- Heap

* Brainstorming
Option 2:
Compiler -> bytecode

Mima:
Interpreter <- bytecode
