#+TITLE: Readme

* TODO Stage 1 Parser & Interpreter
** Parser
- [X] while loop
- [X] for loop
- [X] conditionals
- [ ] tenary operator
- [X] IO printf function
- [X] return
- [ ] break
- [ ] continue
- [ ] Arrays
- [ ] Stringliterals
- [ ] Charliterals

** Interpreter
- [ ] Scope
- [ ] while loop
- [ ] for loop
- [ ] tenary operator
- [ ] Conditionals
- [ ] IO printf function
- [ ] Return
- [ ] Break
- [ ] Continue
- [ ] Arrays

** Sonstiges
- [X] Errorhandling (gegen den gepreprocessten filetext)
- [ ] Test fÃ¼r parsing
  + [ ] Automatic generation?

* Sprache:
1. Arithmetic Expressions
   #+begin_example
   (1 + 2 - 2 / 3 * -5 % 10)
   #+end_example
2. Variables (Assignment)
   #+begin_example
   int a = 5;
   #+end_example
   We differentiate between:
   - Global
   - Local
   Variables
   /Note:/
      Assignment returns the assigned value to allow for:
      #+begin_example
      a = b = 5;
      #+end_example
3. Scope
   - *local* scope:
     #+begin_example
     {
     int a = 1;
     int b = 1;
             {
                 int b = 5;
                 a + b;
             }
     }
     #+end_example
   - *global* scope

4. Function declaration
   If we do a single pass compiler we need forward delaration
   ?How will this work for the compiler?
5. Functiondefinition
   void a(int b, int c) { BODY }
6. Functioncalls
   a(b, c)

* Grammar
#+begin_src
expr         -> varassign
varassign    -> IDENTIFIER = expr
;; this is ok to do recursively because it is right associative
varassign    -> [IDENTIFIER, EQUALS] varassign | add
add          -> (factor [PLUS, MINUS])* factor
factor       -> (mod [MULTIPLY, DIVIDE])* mod
mod          -> (unary [MODULO])* unary
unary        -> MINUS value | value
value        -> INTLITERAL | LPAREN expr RPAREN | functioncall | IDENTIFIER
functioncall -> IDENTIFIER LPAREN (RPAREN | expr (COMMA expr)* RPAREN)
#+end_src

#+begin_src
blockstatement -> ((vardecl | expr)? SEMICOLON | block | for | while | if | return | instrinsic)
for            -> FOR LPAREN (vardecl | expr) SEMICOLON expr SEMICOLON expr RPAREN blockstatement
while          -> WHILE LPAREN expr RPAREN blockstatement
if             -> IF LPAREN expr RPAREN blockstatement (ELSE blockstatement)?
block          -> LBRACE (blockstatment)* RBRACE
return         -> RETURN (expr)? SEMICOLON
intrinsic      -> INTRINSIC LPAREN (RPAREN | expr (COMMA expr)* RPAREN)
#+end_src

#+begin_src
program  -> (statement)*
statement    -> ((vardecl | funcdecl)? SEMICOLON)
vardecl      -> IDENTIFIER IDENTIFIER (= expr)? (, IDENTIFIER (= expr)?)*
funcdecl  -> IDENTIFIER IDENTIFIER LPAREN (RPAREN | IDENTIFIER IDENTIFIER (COMMA IDENTIFIER IDENTIFIER)* RPAREN) ( SEMICOLON | block)
#+end_src


* Modules:
** Preprozessor
- Comments
- (Macros)
** Lexer
- Generates Tokens
Difficulty?:
- Handles strings
** Parser
Generates AST to be used by compiler / interpreter
What type of parser?
- Recursive descent?
- Parser combinators?

** Interpreter
** Compiler (future)
- Single file (at least no linker)
- (type system)

*** Address Space:
- Code
- Data
- Registers (pseudo)
- Stack
- Heap
* Compiler
** Execution environments :5_1_2:
All objects with static storage duration shall be initialized _before_ Program startup

* Brainstorming
Option 2:
Compiler -> bytecode

Mima:
Interpreter <- bytecode
